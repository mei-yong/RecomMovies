

Useful Links

// Cypher Shell
// https://neo4j.com/docs/operations-manual/current/tools/cypher-shell/

// Combining 2 Neo4j collections into 1 and getting distinct values from it
// https://stackoverflow.com/questions/34659152/cyhper-combine-two-columns-into-a-single

// Load CSV tips
// https://neo4j.com/developer/guide-import-csv/
// https://gist.github.com/jexp/d788e117129c3730a042


// https://neo4j.com/blog/common-confusions-cypher/
// https://neo4j.com/developer/guide-sql-to-cypher/


// DROP CONSTRAINT ON (book:Book) ASSERT book.isbn IS UNIQUE




// Test CSV load
LOAD CSV WITH HEADERS FROM
"file:///movies.csv"
AS row WITH row LIMIT 1 RETURN row


// Uniqueness constraint on nodes
CREATE CONSTRAINT ON (m:Movie) ASSERT m.id IS UNIQUE;
CREATE CONSTRAINT ON (u:User) ASSERT u.id IS UNIQUE;
CREATE CONSTRAINT ON (a:Artist) ASSERT a.name IS UNIQUE;
CREATE CONSTRAINT ON (g:Genre) ASSERT g.name IS UNIQUE;


// Create movie nodes
USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
MERGE (m:Movie { id: toInteger(row.netflix_id) })
ON CREATE SET
	m.imdb = row.imdb_id,
	m.title = row.title,
	m.year = toInteger(row.year)

// QA movies
MATCH (m:Movie) RETURN COUNT(m) //300
MATCH (m:Movie) RETURN COUNT(DISTINCT m) //300


// Create user nodes
USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///users.csv" AS row
MERGE (u:User {id:toInteger(row.user_id)})
ON CREATE SET u.name = trim(row.name)

// QA users
MATCH (u:User) RETURN COUNT(u) //155
MATCH (u:User) RETURN COUNT(DISTINCT u) //155


// Create rating relationships
USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///ratings.csv" AS row
WITH row, SPLIT(row.rating_date, "-") AS date
MATCH (u:User {id: toInteger(row.user_id)})
MATCH (m:Movie {id: toInteger(row.movie_id)})
MERGE (u)-[r:RATED]->(m)
ON CREATE SET
	r.rating = toInteger(row.rating),
	r.year = toInteger(date[0]),
	r.month = toInteger(date[1]),
	r.day = toInteger(date[2])
	

// QA relationship count
MATCH ()-[r:RATED]-() RETURN COUNT(DISTINCT r) //35594



// Add average rating & total ratings to movie nodes
MATCH (m:Movie)<-[r:RATED]-()
WITH m, 
	AVG(r.rating) as average_rating, 
	COUNT(r.rating) as total_ratings
SET m.avg_rating = round(100* average_rating) / 100,
	m.total_ratings = total_ratings


// Get top 10 highly rated movies
MATCH (m:Movie)
RETURN m.title as movie, m.avg_rating as rating
ORDER BY m.avg_rating DESC LIMIT 10

// Get top 10 least rated movies
MATCH (m:Movie)
RETURN m.title as movie, m.total_ratings as num_ratings
ORDER BY m.total_ratings ASC LIMIT 10


// Try to find hidden gems - movies with few but highly scored ratings
MATCH (m:Movie) WHERE m.avg_rating >=4
RETURN m ORDER BY m.total_ratings ASC LIMIT 50



// Create people and genre nodes

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movie_persons.csv" AS row
WITH row WHERE row.name IS NOT NULL
MERGE (:Artist {name: trim(row.name)})
;

// QA actor nodes
MATCH (a:Artist) WHERE a.name='Johnny Depp' RETURN a
MATCH (a:Artist) RETURN COUNT(a) //849
MATCH (a:Artist) RETURN COUNT(DISTINCT a) //849


USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movie_genres.csv" AS row
WITH row WHERE row.name IS NOT NULL
MERGE (:Genre {name: toLower(trim(row.name))})
;

// QA genre nodes
MATCH (g:Genre) RETURN COUNT(g) //24
MATCH (g:Genre) RETURN COUNT(DISTINCT g) //24




// Create relationships between people, genres, and movies

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
MATCH (m:Movie {id: toInteger(row.netflix_id)})
MATCH (a:Artist {name: row.director})
MERGE (m)<-[:DIRECTED]-(a)
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
MATCH (m:Movie {id: toInteger(row.netflix_id)})
MATCH (a:Artist {name: row.actor_1})
MERGE (m)<-[:ACTED_IN]-(a)
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
MATCH (m:Movie {id: toInteger(row.netflix_id)})
MATCH (a:Artist {name: row.actor_2})
MERGE (m)<-[:ACTED_IN]-(a)
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
MATCH (m:Movie {id: toInteger(row.netflix_id)})
MATCH (a:Artist {name: row.actor_3})
MERGE (m)<-[:ACTED_IN]-(a)
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
MATCH (m:Movie {id: toInteger(row.netflix_id)})
MATCH (g:Genre {name: toLower(row.genre_1)})
MERGE (m)-[:HAS_GENRE]->(g)
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
MATCH (m:Movie {id: toInteger(row.netflix_id)})
MATCH (g:Genre {name: toLower(row.genre_2)})
MERGE (m)-[:HAS_GENRE]->(g)
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
MATCH (m:Movie {id: toInteger(row.netflix_id)})
MATCH (g:Genre {name: toLower(row.genre_3)})
MERGE (m)-[:HAS_GENRE]->(g)
;


// Test to see if nodes and relationships were created correctly
MATCH (m:Movie)-[r]-(n) WHERE m.title CONTAINS 'Final Fantasy' RETURN m, r, n
MATCH (m:Movie)-[r]-(n) WHERE m.title CONTAINS 'Pacifier' RETURN m, r, n





























USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
WITH row WHERE row.director IS NOT NULL
MERGE (:Person {name: trim(row.director)})
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
WITH row WHERE row.actor_1 IS NOT NULL
MERGE (:Person {name: trim(row.actor_1)})
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
WITH row WHERE row.actor_2 IS NOT NULL
MERGE (:Person {name: trim(row.actor_2)})
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
WITH row WHERE row.actor_3 IS NOT NULL
MERGE (:Person {name: trim(row.actor_3)})
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
WITH row WHERE row.genre_1 IS NOT NULL OR toLower(row.genre_1) = 'nan'
MERGE (:Genre {name: trim(row.genre_1)})
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
WITH row WHERE row.genre_2 IS NOT NULL OR toLower(row.genre_2) = 'nan'
MERGE (:Genre {name: trim(row.genre_2)})
;

USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS
FROM "file:///movies_imdb.csv" AS row
WITH row WHERE row.genre_3 IS NOT NULL OR toLower(row.genre_3) = 'nan'
MERGE (:Genre {name:trim(row.genre_3)})
;



